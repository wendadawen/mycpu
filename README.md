将你的CPU RTL代码放在此处

# 命名要求
- 所有阶段均以下划线+阶段命名
- 所有控制变量用首字母大写命名
- 其他用小写下划线命名

# 52条指令
## 控制信号
``` verilog
- MemtoReg,  // MemtoReg = 0，从ALU结果中取值
- MemWrite,  // MemWrite = 0，不涉及内存写入
- Branch,    // Branch = 0，  不涉及分支
- ALUSrc,    // ALUSrc = 0，  第二个操作数来自rs寄存器
- RegDst,    // RegDst = 0，  不将结果存储到rd寄存器中
- RegWrite,  // RegWrite = 0，不将结果写入寄存器
- Jump       // Jump = 0，    不涉及跳转
- HI 寄存器的写信号
- LO 寄存器的写信号
- 寄存器堆写数据的选择信号
- BNE、BGEZ、BGTZ、BLEZ、BLTZ的添加
这5条指令功能和BEQ类似，区别在于它们判断是否跳转的方式不一样
数据通路方面，只需要对生成是否跳转信号的逻辑进行扩展即可，其余功能可直接复用BEQ的通路。
控制信号方面，要分别生成对应的控制信号，用于控制比较逻辑，可参照BEQ指令
- JR的添加
JR指令的功能与J指令完全相同，都是无条件跳转到目标地址，区别在于JR指令的跳转目标地址来自通用寄存器堆的第rs项。
数据通路只需新增寄存器堆的rdata1端口连接到生成下一个PC的多选器的输入。
要添加新的控制信号，用于控制下一个PC的选择
- JAL指令
根据指令规范文档可知，JAL指令完成跳转目标地址的生成，并将PC+8写入到 31号 寄存器中。跳转这部分功能可以复用J指令的数据通路，而保存返回地址的操作在原有的基础上无法完成，需要增加新的数据通路。
写寄存器涉及到写端口的地址和写数据，所以对于写地址，需要调整通用寄存器堆写端口的地址输入waddr的生成逻辑，增加一个固定数值31作为新的输入；而对于写数据，需要得到PC+8，可以复用ALU的加法器，只不过第一个源操作数原来是仅来自寄存器堆的第一个输出端口，需要添加一个二选一部件，使其可以选择PC作为第一个源操作数，第二个需要将原有的二选一部件调整为三选一部件，8作为第三个输入。

JAL的添加
由于新增或修改了ALU两个源操作数的多选器，所以要相应的生成或修改这两个多选器的控制信号，让JAL指令执行时可以选择到PC和8
- JALR指令
JALR指令的功能类似于JR和JAL的结合。对于跳转操作，可以复用JR指令对应的数据通路。对于Link操作，其返回地址的计算还是PC+8，这与JAL指令是一样的，不过计算的结果不再固定写到31号通用寄存器中，而是写入第rd项寄存器。因此JALR指令可以复用JAL指令计算PC+8并传递的数据通路，无需新增，只是写回级控制信号有所区别。
相比于JAL指令，JALR指令不再写入31号寄存器，所以在写回级的控制信号需要将写寄存器的来源选择为指令rd域。
```